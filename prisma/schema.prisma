generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTH
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String
  name          String?
  role          UserRole  @default(OWNER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  projects              Project[]
  implementerProjects   Project[] @relation("ImplementerProjects")
  sessions              Session[]

  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

enum UserRole {
  OWNER
  ADMIN
}

// ============================================
// CLIENTS
// ============================================

model Client {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects  Project[]

  @@map("clients")
}

// ============================================
// PROJECTS
// ============================================

model Project {
  id             String        @id @default(cuid())
  name           String
  slug           String        @unique
  status         ProjectStatus @default(INTAKE)
  projectType    ProjectType   @default(NEW_PROJECT)

  // Intake data (business questions)
  intakeData     Json

  // Target codebase (for bug fixes/enhancements to existing projects)
  // If set, implementation runs in this folder instead of creating a new one
  // Required for NEW_FEATURE and BUG_FIX types
  targetCodebase String?

  // For BUG_FIX: brief description of the issue (simpler than full intake)
  bugDescription String?       @db.Text

  // AI-generated artifacts
  pmPlan         Json?
  ctoArchitecture Json?
  summary        String?       @db.Text

  // Approval
  approvalStatus ApprovalStatus @default(PENDING)
  approvalNotes  String?        @db.Text
  approvedAt     DateTime?

  // Relationships
  clientId       String
  ownerId        String
  implementerId  String?  // Assigned implementer who can also view project documents

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  client             Client   @relation(fields: [clientId], references: [id])
  owner              User     @relation(fields: [ownerId], references: [id])
  implementer        User?    @relation("ImplementerProjects", fields: [implementerId], references: [id])
  sprints            Sprint[]
  conversations      Conversation[]
  artifacts          Artifact[]
  referenceDocuments ReferenceDocument[]

  @@map("projects")
}

enum ProjectStatus {
  INTAKE
  PLANNING
  REVIEW
  APPROVED
  IN_PROGRESS
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REVISION_REQUESTED
  REJECTED
}

enum ProjectType {
  NEW_PROJECT    // Brand new application, needs new repo
  NEW_FEATURE    // Adding feature to existing codebase, feature branch + PR
  BUG_FIX        // Simple fix, minimal workflow, quick branch + PR
}

// ============================================
// SPRINTS
// ============================================

model Sprint {
  id          String       @id @default(cuid())
  projectId   String
  number      Int
  name        String?
  status      SprintStatus @default(PLANNED)
  goal        String?      @db.Text
  startDate   DateTime?
  endDate     DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  reviewSummary String?    @db.Text
  devServerUrl  String?    // URL to test/preview the sprint deliverables

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id])
  reviews     SprintReview[]

  @@unique([projectId, number])
  @@map("sprints")
}

enum SprintStatus {
  PLANNED
  IN_PROGRESS
  ACTIVE
  REVIEW
  COMPLETED
  AWAITING_APPROVAL  // Next sprint waiting for human approval to start
}

model SprintReview {
  id              String   @id @default(cuid())
  sprintId        String

  conversationLog Json?
  statusDocument  String?  @db.Text

  createdAt       DateTime @default(now())

  sprint          Sprint   @relation(fields: [sprintId], references: [id])

  @@map("sprint_reviews")
}

// ============================================
// CONVERSATIONS
// ============================================

model Conversation {
  id        String   @id @default(cuid())
  projectId String

  role      String
  type      String

  input     Json
  output    Json

  tokenCount Int?

  createdAt DateTime @default(now())

  project   Project  @relation(fields: [projectId], references: [id])

  @@index([projectId, createdAt])
  @@map("conversations")
}

// ============================================
// ARTIFACTS
// ============================================

model Artifact {
  id        String       @id @default(cuid())
  projectId String

  type      ArtifactType
  name      String
  content   String       @db.Text
  version   Int          @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project   Project  @relation(fields: [projectId], references: [id])

  @@unique([projectId, type, version])
  @@map("artifacts")
}

enum ArtifactType {
  BACKLOG
  ARCHITECTURE
  HANDOFF
  HANDOFF_PM_TO_CTO
  HANDOFF_CTO_TO_IMPLEMENTER
  SUMMARY
  SPRINT_STATUS
}

// ============================================
// REFERENCE DOCUMENTS
// ============================================

model ReferenceDocument {
  id        String   @id @default(cuid())
  projectId String

  // File metadata
  name      String          // Original filename
  mimeType  String          // MIME type (e.g., application/pdf)
  size      Int             // File size in bytes

  // Content storage (base64 encoded for smaller files)
  content   String   @db.Text

  createdAt DateTime @default(now())

  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@map("reference_documents")
}

// ============================================
// KNOWLEDGE BASE
// ============================================

model KnowledgeEntry {
  id          String            @id @default(cuid())

  // Categorization
  category    KnowledgeCategory
  tags        String[]          // Searchable tags

  // Content
  title       String
  content     String            @db.Text

  // Source tracking
  sourceRole  String            // Which AI role created this
  sourceType  String            // slack_conversation, handoff, retrospective, incident, etc.
  projectId   String?           // Optional link to project

  // Verification status (human review)
  verified    Boolean           @default(false)
  verifiedAt  DateTime?
  verifiedBy  String?

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([category, tags])
  @@index([sourceRole])
  @@index([projectId])
  @@map("knowledge_entries")
}

enum KnowledgeCategory {
  DECISION        // Technical or process decisions
  LESSON_LEARNED  // What we learned from experience
  PROCEDURE       // SOPs and how-to guides
  CLIENT_INFO     // Client preferences and history
  TECHNICAL       // Technical knowledge and patterns
  INCIDENT        // Post-incident learnings
}
